#include <pspsdk.h>
#include <pspkernel.h>
#include <pspnand_driver.h>

#include "up_driver.h"


PSP_MODULE_INFO("UP_driver", 0x1006, 1, 1);
PSP_MAIN_THREAD_ATTR(0);

#define NAND_STATUS (*((volatile unsigned *)0xBD101004))
#define NAND_COMMAND (*((volatile unsigned *)0xBD101008))
#define NAND_ADDRESS (*((volatile unsigned *)0xBD10100C))
#define NAND_READDATA (*((volatile unsigned *)0xBD101300))
#define NAND_ENDTRANS (*((volatile unsigned *)0xBD101014))

u32 commands[20] =
{
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01,
	0x00, 0x00, 0x01, 0xFF 
};

u8 commands_2[20] =
{
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01,
	0x01, 0x01, 0x00, 0xFF
};

#define MIPS_LUI(R,IMM) 0x3c000000|(R<<16)|((unsigned int)(IMM)&0xffff)

#define MIPS_ADDI(RT,RS,IMM)  (0x20000000|(RS<<21)|(RT<<16)|((unsigned int)(IMM)&0xffff))
#define MIPS_ADDIU(RT,RS,IMM) (0x24000000|(RS<<21)|(RT<<16)|((unsigned int)(IMM)&0xffff))
#define MIPS_ANDI(RT,RS,IMM)  (0x30000000|(RS<<21)|(RT<<16)|((unsigned int)(IMM)&0xffff))
#define MIPS_ORI(RT,RS,IMM)   (0x34000000|(RS<<21)|(RT<<16)|((unsigned int)(IMM)&0xffff))
#define MIPS_NOP              0x00000000
#define MIPS_J(ADDR)          (0x08000000 + ((((unsigned int)(ADDR))&0x0ffffffc)>>2))
#define MIPS_JR(R)            (0x00000008 + ((R)<<21))
#define MIPS_JAL(ADDR)        (0x0c000000 + (((unsigned int)(ADDR)>>2)&0x03ffffff))
#define MIPS_SYSCALL(NUM)     (0x0000000C+((NUM)<<6))

#define MIPS_AND(RD,RS,RT)  (0x00000024|(RD<<11)|(RT<<16)|(RS<<21))
#define MIPS_ADD(RD,RS,RT)  (0x00000020|(RD<<11)|(RT<<16)|(RS<<21))
#define MIPS_ADDU(RD,RS,RT) (0x00000021|(RD<<11)|(RT<<16)|(RS<<21))

#define MIPS_SW(RT,BASE,OFFSET) (0xac000000|(BASE<<21)|(RT<<16)|(OFFSET&0xFFFF))
#define MIPS_SH(RT,BASE,OFFSET) (0xa4000000|(BASE<<21)|(RT<<16)|(OFFSET&0xFFFF))

int upSetActiveNand(int unit)
{
	//int k1 = pspSdkSetK1(0);
	int i;

	commands[19] = unit;

	for (i = 0; i < 20; i++)
	{
		NAND_COMMAND = commands[i];
		NAND_ADDRESS = 0;
		NAND_ENDTRANS = 1;
	}

	//pspSdkSetK1(k1);
	return 0;
}

int upSetActiveNandWithWait(int unit)
{
	upSetActiveNand(unit);

	while (upGetActiveNand() != unit);
	return 0;
}

int upGetActiveNand()
{
	//int k1 = pspSdkSetK1(0);
	int i;
	u8 read; 

	commands_2[19] = 1; 

	for (i = 0; i < 20; i++)
	{
		NAND_COMMAND = commands_2[i];
	}

	read = (u8)NAND_READDATA;

	commands_2[19] = 0; 

	for (i = 0; i < 20; i++)
	{
		NAND_COMMAND = commands_2[i];
	}

	NAND_ENDTRANS = 1;

	//pspSdkSetK1(k1);
	return (read >> 2);
}

int upSetActiveFlash(int unit)
{
	//int k1 = pspSdkSetK1(0);
	
	sceIoUnassign("flash0:");
	sceIoUnassign("flash1:");

	sceNandLock(0);
	upSetActiveNand(unit);	
	sceNandUnlock();

	sceIoAssign("flash0:", "lflash0:0,0", "flashfat0:", 0, IOASSIGN_RDWR , 0);
	sceIoAssign("flash1:", "lflash0:0,1", "flashfat1:", 0, IOASSIGN_RDWR , 0);

	//pspSdkSetK1(k1);
	return 0;
}

int upSetActiveFlashWithWait(int unit)
{
	int k1 = pspSdkSetK1(0);
	
	sceIoUnassign("flash0:");
	sceIoUnassign("flash1:");

	sceNandLock(0);

	upSetActiveNand(unit);
	while (upGetActiveNand() != unit);

	sceNandUnlock();

	sceIoAssign("flash0:", "lflash0:0,0", "flashfat0:", 0, IOASSIGN_RDWR , 0);
	sceIoAssign("flash1:", "lflash0:0,1", "flashfat1:", 0, IOASSIGN_RDWR , 0);

	pspSdkSetK1(k1);
	return 0;
}

int upNandLock(int writeflag)
{
	int k1 = pspSdkSetK1(0);
	int res = sceNandLock(writeflag);
	
	pspSdkSetK1(k1);
	return res;
}

int upNandUnlock()
{
	int k1 = pspSdkSetK1(0);
	sceNandUnlock();
	
	pspSdkSetK1(k1);
	return 0;
}

int module_start(SceSize args, void *argp)
{
	sceNandLock(0);
	upSetActiveNand(PSP_NAND);
	while (upGetActiveNand() != PSP_NAND);
	sceNandUnlock();
	
	return 0;
}



